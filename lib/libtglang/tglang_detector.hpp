#pragma once

#include <iostream>
#include <vector>

#include <tensorflow/lite/interpreter.h>
#include <tensorflow/lite/kernels/register.h>
#include <tensorflow/lite/logger.h>

#include <model.hpp>      // Generated by `xxd -i model.tflite > model.h`
#include <model_meta.hpp> // Generated by python script

#include "tglang.h"
#include "tglang_preprocessor.hpp"

class TglangDetector
{
    std::unique_ptr<tflite::FlatBufferModel> model = tflite::FlatBufferModel::BuildFromBuffer(reinterpret_cast<const char *>(model_tflite), model_tflite_len);
    tflite::ops::builtin::BuiltinOpResolver resolver;
    std::unique_ptr<tflite::Interpreter> interpreter;
    TglangPreprocessor preprocessor;

    void init_interpreter()
    {
        tflite::LoggerOptions::SetMinimumLogSeverity(tflite::LogSeverity::TFLITE_LOG_SILENT);
        tflite::InterpreterBuilder(*model, this->resolver)(&this->interpreter);
        this->interpreter->SetNumThreads(6);
    }

public:
    TglangDetector() { this->init_interpreter(); }

    enum TglangLanguage detect_programming_language(const char *text)
    {
        /* Encode input text to tokens */
        std::vector<det_int_t> input_data = this->preprocessor.preprocess(text);
        if (input_data.size() == 0)
            return TGLANG_LANGUAGE_OTHER;

        /* Allocate buffers */
        std::vector<int> dims = {(int)input_data.size()};
        if (interpreter->ResizeInputTensor(interpreter->inputs()[0], dims) != kTfLiteOk)
        {
            std::cerr << "Failed to resize input tensor." << std::endl;
            return TGLANG_LANGUAGE_OTHER;
        }
        if (interpreter->AllocateTensors() != kTfLiteOk)
        {
            std::cerr << "Failed to allocate tensors." << std::endl;
            return TGLANG_LANGUAGE_OTHER;
        }

        /* Copy tokens to buffers */
        det_int_t *input = this->interpreter->typed_input_tensor<det_int_t>(0);
        std::copy(input_data.begin(), input_data.end(), input);

        /* Call tflite */
        if (this->interpreter->Invoke() != kTfLiteOk)
        {
            std::cerr << "Failed to invoke interpreter." << std::endl;
            return TGLANG_LANGUAGE_OTHER;
        }

        det_int_t label = *this->interpreter->typed_output_tensor<det_int_t>(0);
        float confidence = *this->interpreter->typed_output_tensor<float>(1);

        if (confidence < DETECTION_THRESHOLD)
            return TGLANG_LANGUAGE_OTHER;

        return (enum TglangLanguage)label;
    }
};
